"use strict";(self.webpackChunktm_docs=self.webpackChunktm_docs||[]).push([[826],{3905:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return f}});var n=r(7294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var u=n.createContext({}),s=function(e){var t=n.useContext(u),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=s(e.components);return n.createElement(u.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,u=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),p=s(r),f=o,m=p["".concat(u,".").concat(f)]||p[f]||l[f]||a;return r?n.createElement(m,i(i({ref:t},d),{},{components:r})):n.createElement(m,i({ref:t},d))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=p;var c={};for(var u in t)hasOwnProperty.call(t,u)&&(c[u]=t[u]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<a;s++)i[s]=r[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},3419:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return c},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return d},default:function(){return p}});var n=r(7462),o=r(3366),a=(r(7294),r(3905)),i=["components"],c={id:"reducers",title:"Extending data formatting"},u=void 0,s={unversionedId:"Advanced/reducers",id:"Advanced/reducers",isDocsHomePage:!1,title:"Extending data formatting",description:"With Trial Monitor we try to do some educated guesses regarding how data is structured based on each database type. Once data is retrieved it goes through our internal functions to be formatted so it can be interpreted by the UI components. While this works in most situations, data might be stored in a structured not supported. Understanding these use cases, it is possible to construct your own parsing functions to have control over the formatting process.",source:"@site/docs/04-Advanced/reducers.md",sourceDirName:"04-Advanced",slug:"/Advanced/reducers",permalink:"/trial-monitor/Advanced/reducers",tags:[],version:"current",frontMatter:{id:"reducers",title:"Extending data formatting"},sidebar:"tutorialSidebar",previous:{title:"Dashboard",permalink:"/trial-monitor/UI Definition/dashboard"}},d=[{value:"Creating the reducer function",id:"creating-the-reducer-function",children:[]},{value:"Using the reducer",id:"using-the-reducer",children:[]}],l={toc:d};function p(e){var t=e.components,r=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,n.Z)({},l,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"With Trial Monitor we try to do some educated guesses regarding how data is structured based on each database type. Once data is retrieved it goes through our internal functions to be formatted so it can be interpreted by the UI components. While this works in most situations, data might be stored in a structured not supported. Understanding these use cases, it is possible to construct your own parsing functions to have control over the formatting process."),(0,a.kt)("p",null,"This can be accomplished by writing a reducer function that receives data as input, perform a set of operations over it and return the resulting data as an output."),(0,a.kt)("h2",{id:"creating-the-reducer-function"},"Creating the reducer function"),(0,a.kt)("p",null,"To create a new reducer function:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Add a new file to the ",(0,a.kt)("inlineCode",{parentName:"li"},"config/reducers")," directory"),(0,a.kt)("li",{parentName:"ol"},"Export a function that will transform your data")),(0,a.kt)("p",null,"That function will receive two arguments. The first argument is the data retrieved from the database without any processing; the second argument contains an object with custom arguments passed to the reducer."),(0,a.kt)("p",null,"Within that function transform the data according to your requirements and return the resulting data. Each UI component will expected different data structure, so check the documentation of the component for details of how data should be exported."),(0,a.kt)("p",null,"Example of a reducer function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"exports.groupAndFilterData = (data, args) =>  {\n  const filteredData = data.filter(el => el.id === args.id)\n\n  const measuresGrouped = filteredData.reduce((acc, curr) => {\n    acc[curr.id] = acc[curr.id] || []\n    acc[curr.id].push(curr)\n    return acc\n  }, {})\n\n  return {\n    x: Object.keys(measuresGrouped),\n    y: Object.values(measuresGrouped)\n  }\n}\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Exported function names must be unique. Do not write function with the same name even if they are in different files.")),(0,a.kt)("h2",{id:"using-the-reducer"},"Using the reducer"),(0,a.kt)("p",null,"To use the function you have created in the previous step, on the specifications of the UI Component add a new property named ",(0,a.kt)("inlineCode",{parentName:"p"},"reducer")," with the value corresponding to the name of the function you are exporting, or an object with the reducer information."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"reducer"),": (string | object) Name of the reducer function, or an object with the ",(0,a.kt)("inlineCode",{parentName:"li"},"name")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"args")," properties:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"name"),": Name of the reducer function"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"args"),": (optional) Custom object with additional properties you want to pass to the reducer.")))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"reducer: groupAndFilterData\n\n# --- OR ---\n\nreducer:\n  name: groupAndFilterData\n  args:\n    id: 8\n")))}p.isMDXComponent=!0}}]);